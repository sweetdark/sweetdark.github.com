---
layout: post
title: "集合"
date: 2013-01-04 22:46
comments: true
categories: 
tags: ['算法与数据结构']
---
这里的集合是用链表的方式来实现的。

单向链表的定义：list.h
{% gist 4259013 %}
<!-- more -->
单向链表的实现：

``` c
#include "list.h"
void list_init(List *list, void (*destory) (void *data));
void list_destory(List *list);
int list_ins_next(List *list, ListElement *element, const void *data);
int list_rem_next(List *list, ListElement *element, void **data);
#define list_size(list) ((list)->size)
#define list_head(list) ((list)->head)
#define list_tail(list)	((list)->tail)
#define list_is_head(list, element) ((element) == (list->head) ? 1 : 0)
#define list_is_tail(element)		((element)->next == NULL ? 1 : 0)
#define list_data(element)			((element)->data)
#define list_next(element)			((element)->next)


void list_init(List *list, void (*destory)(void *data)) {
	if (list == NULL) return;
	list->size = 0;
	list->match = NULL;
	list->destory = destory;
	list->head = NULL;
	list->tail = NULL;
}

void list_destory(List *list) {
	if (list == NULL) return;
	void *data;
	while (list_size(list) > 0) {
		if (list_rem_next(list, NULL, (void **)&data) == 0 && list->destory != NULL) {
			list->destory(data);
		}	
	}
	memset(list, 0, sizeof(list));
}

int list_ins_next(List *list, ListElement *elem, const void *data) {
	if (!list) return -1;
	ListElement *ins_elem = (ListElement*)malloc(sizeof(ListElement));
	list_data(ins_elem) = data;
	list_next(ins_elem) = NULL;
	if (!elem) {
		if (list_size(list) == 0)  list_tail(list) = ins_elem;
		list_next(ins_elem) = list_head(list);
		list_head(list) = ins_elem;
	} else {
		if (list_next(elem) == NULL) list_tail(list) = ins_elem;
		list_next(ins_elem) = list_next(elem);
		list_next(elem) = ins_elem;
	}
	list->size++;
	return 0;
}

int list_rem_next(List *list, ListElement *elem, void **data) {
	if (!list || list_size(list) == 0) return -1;
	ListElement *old_element;
	if (!elem) {
		*data = list_data(list_head(list));
		old_element = list_head(list);
		list_head(list) = list_next(list_head(list)); 
		
		if (list_size(list) == 1) list->tail = NULL;
	} else {
		if (elem->next == NULL) return -1;
		*data = list_data(list_next(elem));
		old_element = (list_next(elem));
		list_next(elem) = list_next(list_next(elem));
		
		if (elem->next == NULL) list->tail = elem;
	}
	free(old_element);
	list_size(list)--;
	return 0;
}
```

集合用链表的方式实现的，通过typedef来实现简单的多态，集合的操作包括，求交集，并集，差集，判断一个元素是否在集合中，判断一个集合是否是另外一个集合的子集。
``` c set.h
#ifndef SET_H
#define SET_H

#include <stdlib.h>
#include "list.h"

typedef List Set;

typedef ListElement SetElement;

void set_init(Set *set, int (*match)(void *data1, void *data2), void (*destory)(void *data));

#define set_destory list_destory
int set_insert(Set *set, const void *data);

int set_remove(Set *set, void **data);

int set_union(Set *setu, const Set *set1, const Set *set2);

int set_insertion(Set *seti, const Set *set1, const Set *set2);

int set_deffirence(Set *setd, const Set *set1, const Set *set2);

int set_ismember(const Set *set, void *data);

int set_issubset(const Set *set1, const Set *set2);

int set_is_equal(const Set *set1, const Set *set2);
#define set_size(set) list_size(set)
#define set_data(element) list_data(element)

#endif
```
*(未完待续)*
